// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_position_estimate::_get_position_estimate_output::GetPositionEstimateOutputBuilder;

pub use crate::operation::get_position_estimate::_get_position_estimate_input::GetPositionEstimateInputBuilder;

impl GetPositionEstimateInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::get_position_estimate::GetPositionEstimateOutput,
        ::aws_smithy_http::result::SdkError<
            crate::operation::get_position_estimate::GetPositionEstimateError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.get_position_estimate();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `GetPositionEstimate`.
///
/// <p>Get estimated position information as a payload in GeoJSON format. The payload measurement data is resolved using solvers that are provided by third-party vendors.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct GetPositionEstimateFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_position_estimate::builders::GetPositionEstimateInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl GetPositionEstimateFluentBuilder {
    /// Creates a new `GetPositionEstimate`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the GetPositionEstimate as a reference.
    pub fn as_input(&self) -> &crate::operation::get_position_estimate::builders::GetPositionEstimateInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::get_position_estimate::GetPositionEstimateOutput,
        ::aws_smithy_http::result::SdkError<
            crate::operation::get_position_estimate::GetPositionEstimateError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self.inner.build().map_err(::aws_smithy_http::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::get_position_estimate::GetPositionEstimate::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::get_position_estimate::GetPositionEstimate::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being
    /// sent.
    // TODO(enableNewSmithyRuntimeCleanup): Remove `async` and `Result` once we switch to orchestrator
    pub async fn customize(
        self,
    ) -> ::std::result::Result<
        crate::client::customize::orchestrator::CustomizableOperation<
            crate::operation::get_position_estimate::GetPositionEstimateOutput,
            crate::operation::get_position_estimate::GetPositionEstimateError,
        >,
        ::aws_smithy_http::result::SdkError<crate::operation::get_position_estimate::GetPositionEstimateError>,
    > {
        ::std::result::Result::Ok(crate::client::customize::orchestrator::CustomizableOperation {
            customizable_send: ::std::boxed::Box::new(move |config_override| {
                ::std::boxed::Box::pin(async { self.config_override(config_override).send().await })
            }),
            config_override: None,
            interceptors: vec![],
            runtime_plugins: vec![],
        })
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Appends an item to `WiFiAccessPoints`.
    ///
    /// To override the contents of this collection use [`set_wi_fi_access_points`](Self::set_wi_fi_access_points).
    ///
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn wi_fi_access_points(mut self, input: crate::types::WiFiAccessPoint) -> Self {
        self.inner = self.inner.wi_fi_access_points(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn set_wi_fi_access_points(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>>) -> Self {
        self.inner = self.inner.set_wi_fi_access_points(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn get_wi_fi_access_points(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WiFiAccessPoint>> {
        self.inner.get_wi_fi_access_points()
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn cell_towers(mut self, input: crate::types::CellTowers) -> Self {
        self.inner = self.inner.cell_towers(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn set_cell_towers(mut self, input: ::std::option::Option<crate::types::CellTowers>) -> Self {
        self.inner = self.inner.set_cell_towers(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn get_cell_towers(&self) -> &::std::option::Option<crate::types::CellTowers> {
        self.inner.get_cell_towers()
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn ip(mut self, input: crate::types::Ip) -> Self {
        self.inner = self.inner.ip(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn set_ip(mut self, input: ::std::option::Option<crate::types::Ip>) -> Self {
        self.inner = self.inner.set_ip(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn get_ip(&self) -> &::std::option::Option<crate::types::Ip> {
        self.inner.get_ip()
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn gnss(mut self, input: crate::types::Gnss) -> Self {
        self.inner = self.inner.gnss(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn set_gnss(mut self, input: ::std::option::Option<crate::types::Gnss>) -> Self {
        self.inner = self.inner.set_gnss(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn get_gnss(&self) -> &::std::option::Option<crate::types::Gnss> {
        self.inner.get_gnss()
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.timestamp(input);
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn set_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_timestamp(input);
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the Unix timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn get_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        self.inner.get_timestamp()
    }
}
