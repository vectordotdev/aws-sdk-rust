// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub(crate) fn reflens_list_firewall_configs_output_next_token(
    input: &crate::operation::list_firewall_configs::ListFirewallConfigsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_firewall_domain_lists_output_next_token(
    input: &crate::operation::list_firewall_domain_lists::ListFirewallDomainListsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_firewall_domains_output_next_token(
    input: &crate::operation::list_firewall_domains::ListFirewallDomainsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_firewall_rule_group_associations_output_next_token(
    input: &crate::operation::list_firewall_rule_group_associations::ListFirewallRuleGroupAssociationsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_firewall_rule_groups_output_next_token(
    input: &crate::operation::list_firewall_rule_groups::ListFirewallRuleGroupsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_firewall_rules_output_next_token(
    input: &crate::operation::list_firewall_rules::ListFirewallRulesOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_outpost_resolvers_output_next_token(
    input: &crate::operation::list_outpost_resolvers::ListOutpostResolversOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_configs_output_next_token(
    input: &crate::operation::list_resolver_configs::ListResolverConfigsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_dnssec_configs_output_next_token(
    input: &crate::operation::list_resolver_dnssec_configs::ListResolverDnssecConfigsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_endpoint_ip_addresses_output_next_token(
    input: &crate::operation::list_resolver_endpoint_ip_addresses::ListResolverEndpointIpAddressesOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_endpoints_output_next_token(
    input: &crate::operation::list_resolver_endpoints::ListResolverEndpointsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_query_log_config_associations_output_next_token(
    input: &crate::operation::list_resolver_query_log_config_associations::ListResolverQueryLogConfigAssociationsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_query_log_configs_output_next_token(
    input: &crate::operation::list_resolver_query_log_configs::ListResolverQueryLogConfigsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_rule_associations_output_next_token(
    input: &crate::operation::list_resolver_rule_associations::ListResolverRuleAssociationsOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_resolver_rules_output_next_token(
    input: &crate::operation::list_resolver_rules::ListResolverRulesOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn reflens_list_tags_for_resource_output_next_token(
    input: &crate::operation::list_tags_for_resource::ListTagsForResourceOutput,
) -> ::std::option::Option<&::std::string::String> {
    let input = match &input.next_token {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_configs_output_firewall_configs(
    input: crate::operation::list_firewall_configs::ListFirewallConfigsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::FirewallConfig>> {
    let input = match input.firewall_configs {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_domain_lists_output_firewall_domain_lists(
    input: crate::operation::list_firewall_domain_lists::ListFirewallDomainListsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::FirewallDomainListMetadata>> {
    let input = match input.firewall_domain_lists {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_domains_output_domains(
    input: crate::operation::list_firewall_domains::ListFirewallDomainsOutput,
) -> ::std::option::Option<::std::vec::Vec<::std::string::String>> {
    let input = match input.domains {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_rule_group_associations_output_firewall_rule_group_associations(
    input: crate::operation::list_firewall_rule_group_associations::ListFirewallRuleGroupAssociationsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::FirewallRuleGroupAssociation>> {
    let input = match input.firewall_rule_group_associations {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_rule_groups_output_firewall_rule_groups(
    input: crate::operation::list_firewall_rule_groups::ListFirewallRuleGroupsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::FirewallRuleGroupMetadata>> {
    let input = match input.firewall_rule_groups {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_firewall_rules_output_firewall_rules(
    input: crate::operation::list_firewall_rules::ListFirewallRulesOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::FirewallRule>> {
    let input = match input.firewall_rules {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_outpost_resolvers_output_outpost_resolvers(
    input: crate::operation::list_outpost_resolvers::ListOutpostResolversOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::OutpostResolver>> {
    let input = match input.outpost_resolvers {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_configs_output_resolver_configs(
    input: crate::operation::list_resolver_configs::ListResolverConfigsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverConfig>> {
    let input = match input.resolver_configs {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_dnssec_configs_output_resolver_dnssec_configs(
    input: crate::operation::list_resolver_dnssec_configs::ListResolverDnssecConfigsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverDnssecConfig>> {
    let input = match input.resolver_dnssec_configs {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_endpoint_ip_addresses_output_ip_addresses(
    input: crate::operation::list_resolver_endpoint_ip_addresses::ListResolverEndpointIpAddressesOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::IpAddressResponse>> {
    let input = match input.ip_addresses {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_endpoints_output_resolver_endpoints(
    input: crate::operation::list_resolver_endpoints::ListResolverEndpointsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverEndpoint>> {
    let input = match input.resolver_endpoints {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_query_log_config_associations_output_resolver_query_log_config_associations(
    input: crate::operation::list_resolver_query_log_config_associations::ListResolverQueryLogConfigAssociationsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverQueryLogConfigAssociation>> {
    let input = match input.resolver_query_log_config_associations {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_query_log_configs_output_resolver_query_log_configs(
    input: crate::operation::list_resolver_query_log_configs::ListResolverQueryLogConfigsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverQueryLogConfig>> {
    let input = match input.resolver_query_log_configs {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_rule_associations_output_resolver_rule_associations(
    input: crate::operation::list_resolver_rule_associations::ListResolverRuleAssociationsOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverRuleAssociation>> {
    let input = match input.resolver_rule_associations {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_resolver_rules_output_resolver_rules(
    input: crate::operation::list_resolver_rules::ListResolverRulesOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::ResolverRule>> {
    let input = match input.resolver_rules {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}

pub(crate) fn lens_list_tags_for_resource_output_tags(
    input: crate::operation::list_tags_for_resource::ListTagsForResourceOutput,
) -> ::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
    let input = match input.tags {
        ::std::option::Option::None => return ::std::option::Option::None,
        ::std::option::Option::Some(t) => t,
    };
    ::std::option::Option::Some(input)
}
