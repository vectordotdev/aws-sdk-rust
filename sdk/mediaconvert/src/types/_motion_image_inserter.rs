// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Overlay motion graphics on top of your video. The motion graphics that you specify here appear on all outputs in all output groups. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/motion-graphic-overlay.html.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MotionImageInserter {
    /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the frame rate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the frame rate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay frame rate doesn't need to match the frame rate of the underlying video.
    pub framerate: ::std::option::Option<crate::types::MotionImageInsertionFramerate>,
    /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
    pub input: ::std::option::Option<::std::string::String>,
    /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
    pub insertion_mode: ::std::option::Option<crate::types::MotionImageInsertionMode>,
    /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
    pub offset: ::std::option::Option<crate::types::MotionImageInsertionOffset>,
    /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
    pub playback: ::std::option::Option<crate::types::MotionImagePlayback>,
    /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html
    pub start_time: ::std::option::Option<::std::string::String>,
}
impl MotionImageInserter {
    /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the frame rate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the frame rate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay frame rate doesn't need to match the frame rate of the underlying video.
    pub fn framerate(&self) -> ::std::option::Option<&crate::types::MotionImageInsertionFramerate> {
        self.framerate.as_ref()
    }
    /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
    pub fn input(&self) -> ::std::option::Option<&str> {
        self.input.as_deref()
    }
    /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
    pub fn insertion_mode(&self) -> ::std::option::Option<&crate::types::MotionImageInsertionMode> {
        self.insertion_mode.as_ref()
    }
    /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
    pub fn offset(&self) -> ::std::option::Option<&crate::types::MotionImageInsertionOffset> {
        self.offset.as_ref()
    }
    /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
    pub fn playback(&self) -> ::std::option::Option<&crate::types::MotionImagePlayback> {
        self.playback.as_ref()
    }
    /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html
    pub fn start_time(&self) -> ::std::option::Option<&str> {
        self.start_time.as_deref()
    }
}
impl MotionImageInserter {
    /// Creates a new builder-style object to manufacture [`MotionImageInserter`](crate::types::MotionImageInserter).
    pub fn builder() -> crate::types::builders::MotionImageInserterBuilder {
        crate::types::builders::MotionImageInserterBuilder::default()
    }
}

/// A builder for [`MotionImageInserter`](crate::types::MotionImageInserter).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct MotionImageInserterBuilder {
    pub(crate) framerate: ::std::option::Option<crate::types::MotionImageInsertionFramerate>,
    pub(crate) input: ::std::option::Option<::std::string::String>,
    pub(crate) insertion_mode: ::std::option::Option<crate::types::MotionImageInsertionMode>,
    pub(crate) offset: ::std::option::Option<crate::types::MotionImageInsertionOffset>,
    pub(crate) playback: ::std::option::Option<crate::types::MotionImagePlayback>,
    pub(crate) start_time: ::std::option::Option<::std::string::String>,
}
impl MotionImageInserterBuilder {
    /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the frame rate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the frame rate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay frame rate doesn't need to match the frame rate of the underlying video.
    pub fn framerate(mut self, input: crate::types::MotionImageInsertionFramerate) -> Self {
        self.framerate = ::std::option::Option::Some(input);
        self
    }
    /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the frame rate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the frame rate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay frame rate doesn't need to match the frame rate of the underlying video.
    pub fn set_framerate(mut self, input: ::std::option::Option<crate::types::MotionImageInsertionFramerate>) -> Self {
        self.framerate = input;
        self
    }
    /// If your motion graphic asset is a .mov file, keep this setting unspecified. If your motion graphic asset is a series of .png files, specify the frame rate of the overlay in frames per second, as a fraction. For example, specify 24 fps as 24/1. Make sure that the number of images in your series matches the frame rate and your intended overlay duration. For example, if you want a 30-second overlay at 30 fps, you should have 900 .png images. This overlay frame rate doesn't need to match the frame rate of the underlying video.
    pub fn get_framerate(&self) -> &::std::option::Option<crate::types::MotionImageInsertionFramerate> {
        &self.framerate
    }
    /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
    pub fn input(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.input = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
    pub fn set_input(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.input = input;
        self
    }
    /// Specify the .mov file or series of .png files that you want to overlay on your video. For .png files, provide the file name of the first file in the series. Make sure that the names of the .png files end with sequential numbers that specify the order that they are played in. For example, overlay_000.png, overlay_001.png, overlay_002.png, and so on. The sequence must start at zero, and each image file name must have the same number of digits. Pad your initial file names with enough zeros to complete the sequence. For example, if the first image is overlay_0.png, there can be only 10 images in the sequence, with the last image being overlay_9.png. But if the first image is overlay_00.png, there can be 100 images in the sequence.
    pub fn get_input(&self) -> &::std::option::Option<::std::string::String> {
        &self.input
    }
    /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
    pub fn insertion_mode(mut self, input: crate::types::MotionImageInsertionMode) -> Self {
        self.insertion_mode = ::std::option::Option::Some(input);
        self
    }
    /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
    pub fn set_insertion_mode(mut self, input: ::std::option::Option<crate::types::MotionImageInsertionMode>) -> Self {
        self.insertion_mode = input;
        self
    }
    /// Choose the type of motion graphic asset that you are providing for your overlay. You can choose either a .mov file or a series of .png files.
    pub fn get_insertion_mode(&self) -> &::std::option::Option<crate::types::MotionImageInsertionMode> {
        &self.insertion_mode
    }
    /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
    pub fn offset(mut self, input: crate::types::MotionImageInsertionOffset) -> Self {
        self.offset = ::std::option::Option::Some(input);
        self
    }
    /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
    pub fn set_offset(mut self, input: ::std::option::Option<crate::types::MotionImageInsertionOffset>) -> Self {
        self.offset = input;
        self
    }
    /// Use Offset to specify the placement of your motion graphic overlay on the video frame. Specify in pixels, from the upper-left corner of the frame. If you don't specify an offset, the service scales your overlay to the full size of the frame. Otherwise, the service inserts the overlay at its native resolution and scales the size up or down with any video scaling.
    pub fn get_offset(&self) -> &::std::option::Option<crate::types::MotionImageInsertionOffset> {
        &self.offset
    }
    /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
    pub fn playback(mut self, input: crate::types::MotionImagePlayback) -> Self {
        self.playback = ::std::option::Option::Some(input);
        self
    }
    /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
    pub fn set_playback(mut self, input: ::std::option::Option<crate::types::MotionImagePlayback>) -> Self {
        self.playback = input;
        self
    }
    /// Specify whether your motion graphic overlay repeats on a loop or plays only once.
    pub fn get_playback(&self) -> &::std::option::Option<crate::types::MotionImagePlayback> {
        &self.playback
    }
    /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html
    pub fn start_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.start_time = ::std::option::Option::Some(input.into());
        self
    }
    /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html
    pub fn set_start_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.start_time = input;
        self
    }
    /// Specify when the motion overlay begins. Use timecode format (HH:MM:SS:FF or HH:MM:SS;FF). Make sure that the timecode you provide here takes into account how you have set up your timecode configuration under both job settings and input settings. The simplest way to do that is to set both to start at 0. If you need to set up your job to follow timecodes embedded in your source that don't start at zero, make sure that you specify a start time that is after the first embedded timecode. For more information, see https://docs.aws.amazon.com/mediaconvert/latest/ug/setting-up-timecode.html
    pub fn get_start_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.start_time
    }
    /// Consumes the builder and constructs a [`MotionImageInserter`](crate::types::MotionImageInserter).
    pub fn build(self) -> crate::types::MotionImageInserter {
        crate::types::MotionImageInserter {
            framerate: self.framerate,
            input: self.input,
            insertion_mode: self.insertion_mode,
            offset: self.offset,
            playback: self.playback,
            start_time: self.start_time,
        }
    }
}
