// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes how many instances a stack has for each status.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InstancesCount {
    /// <p>The number of instances in the Assigning state.</p>
    pub assigning: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub booting: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub connection_lost: ::std::option::Option<i32>,
    /// <p>The number of instances in the Deregistering state.</p>
    pub deregistering: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>online</code> status.</p>
    pub online: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub pending: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub rebooting: ::std::option::Option<i32>,
    /// <p>The number of instances in the Registered state.</p>
    pub registered: ::std::option::Option<i32>,
    /// <p>The number of instances in the Registering state.</p>
    pub registering: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub requested: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub running_setup: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub setup_failed: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub shutting_down: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub start_failed: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub stop_failed: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub stopped: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub stopping: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub terminated: ::std::option::Option<i32>,
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub terminating: ::std::option::Option<i32>,
    /// <p>The number of instances in the Unassigning state.</p>
    pub unassigning: ::std::option::Option<i32>,
}
impl InstancesCount {
    /// <p>The number of instances in the Assigning state.</p>
    pub fn assigning(&self) -> ::std::option::Option<i32> {
        self.assigning
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn booting(&self) -> ::std::option::Option<i32> {
        self.booting
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn connection_lost(&self) -> ::std::option::Option<i32> {
        self.connection_lost
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn deregistering(&self) -> ::std::option::Option<i32> {
        self.deregistering
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn online(&self) -> ::std::option::Option<i32> {
        self.online
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn pending(&self) -> ::std::option::Option<i32> {
        self.pending
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn rebooting(&self) -> ::std::option::Option<i32> {
        self.rebooting
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn registered(&self) -> ::std::option::Option<i32> {
        self.registered
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn registering(&self) -> ::std::option::Option<i32> {
        self.registering
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn requested(&self) -> ::std::option::Option<i32> {
        self.requested
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn running_setup(&self) -> ::std::option::Option<i32> {
        self.running_setup
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn setup_failed(&self) -> ::std::option::Option<i32> {
        self.setup_failed
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn shutting_down(&self) -> ::std::option::Option<i32> {
        self.shutting_down
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn start_failed(&self) -> ::std::option::Option<i32> {
        self.start_failed
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn stop_failed(&self) -> ::std::option::Option<i32> {
        self.stop_failed
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn stopped(&self) -> ::std::option::Option<i32> {
        self.stopped
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn stopping(&self) -> ::std::option::Option<i32> {
        self.stopping
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn terminated(&self) -> ::std::option::Option<i32> {
        self.terminated
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn terminating(&self) -> ::std::option::Option<i32> {
        self.terminating
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn unassigning(&self) -> ::std::option::Option<i32> {
        self.unassigning
    }
}
impl InstancesCount {
    /// Creates a new builder-style object to manufacture [`InstancesCount`](crate::types::InstancesCount).
    pub fn builder() -> crate::types::builders::InstancesCountBuilder {
        crate::types::builders::InstancesCountBuilder::default()
    }
}

/// A builder for [`InstancesCount`](crate::types::InstancesCount).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct InstancesCountBuilder {
    pub(crate) assigning: ::std::option::Option<i32>,
    pub(crate) booting: ::std::option::Option<i32>,
    pub(crate) connection_lost: ::std::option::Option<i32>,
    pub(crate) deregistering: ::std::option::Option<i32>,
    pub(crate) online: ::std::option::Option<i32>,
    pub(crate) pending: ::std::option::Option<i32>,
    pub(crate) rebooting: ::std::option::Option<i32>,
    pub(crate) registered: ::std::option::Option<i32>,
    pub(crate) registering: ::std::option::Option<i32>,
    pub(crate) requested: ::std::option::Option<i32>,
    pub(crate) running_setup: ::std::option::Option<i32>,
    pub(crate) setup_failed: ::std::option::Option<i32>,
    pub(crate) shutting_down: ::std::option::Option<i32>,
    pub(crate) start_failed: ::std::option::Option<i32>,
    pub(crate) stop_failed: ::std::option::Option<i32>,
    pub(crate) stopped: ::std::option::Option<i32>,
    pub(crate) stopping: ::std::option::Option<i32>,
    pub(crate) terminated: ::std::option::Option<i32>,
    pub(crate) terminating: ::std::option::Option<i32>,
    pub(crate) unassigning: ::std::option::Option<i32>,
}
impl InstancesCountBuilder {
    /// <p>The number of instances in the Assigning state.</p>
    pub fn assigning(mut self, input: i32) -> Self {
        self.assigning = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances in the Assigning state.</p>
    pub fn set_assigning(mut self, input: ::std::option::Option<i32>) -> Self {
        self.assigning = input;
        self
    }
    /// <p>The number of instances in the Assigning state.</p>
    pub fn get_assigning(&self) -> &::std::option::Option<i32> {
        &self.assigning
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn booting(mut self, input: i32) -> Self {
        self.booting = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn set_booting(mut self, input: ::std::option::Option<i32>) -> Self {
        self.booting = input;
        self
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn get_booting(&self) -> &::std::option::Option<i32> {
        &self.booting
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn connection_lost(mut self, input: i32) -> Self {
        self.connection_lost = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn set_connection_lost(mut self, input: ::std::option::Option<i32>) -> Self {
        self.connection_lost = input;
        self
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn get_connection_lost(&self) -> &::std::option::Option<i32> {
        &self.connection_lost
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn deregistering(mut self, input: i32) -> Self {
        self.deregistering = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn set_deregistering(mut self, input: ::std::option::Option<i32>) -> Self {
        self.deregistering = input;
        self
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn get_deregistering(&self) -> &::std::option::Option<i32> {
        &self.deregistering
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn online(mut self, input: i32) -> Self {
        self.online = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn set_online(mut self, input: ::std::option::Option<i32>) -> Self {
        self.online = input;
        self
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn get_online(&self) -> &::std::option::Option<i32> {
        &self.online
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn pending(mut self, input: i32) -> Self {
        self.pending = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn set_pending(mut self, input: ::std::option::Option<i32>) -> Self {
        self.pending = input;
        self
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn get_pending(&self) -> &::std::option::Option<i32> {
        &self.pending
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn rebooting(mut self, input: i32) -> Self {
        self.rebooting = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn set_rebooting(mut self, input: ::std::option::Option<i32>) -> Self {
        self.rebooting = input;
        self
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn get_rebooting(&self) -> &::std::option::Option<i32> {
        &self.rebooting
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn registered(mut self, input: i32) -> Self {
        self.registered = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn set_registered(mut self, input: ::std::option::Option<i32>) -> Self {
        self.registered = input;
        self
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn get_registered(&self) -> &::std::option::Option<i32> {
        &self.registered
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn registering(mut self, input: i32) -> Self {
        self.registering = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn set_registering(mut self, input: ::std::option::Option<i32>) -> Self {
        self.registering = input;
        self
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn get_registering(&self) -> &::std::option::Option<i32> {
        &self.registering
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn requested(mut self, input: i32) -> Self {
        self.requested = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn set_requested(mut self, input: ::std::option::Option<i32>) -> Self {
        self.requested = input;
        self
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn get_requested(&self) -> &::std::option::Option<i32> {
        &self.requested
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn running_setup(mut self, input: i32) -> Self {
        self.running_setup = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn set_running_setup(mut self, input: ::std::option::Option<i32>) -> Self {
        self.running_setup = input;
        self
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn get_running_setup(&self) -> &::std::option::Option<i32> {
        &self.running_setup
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn setup_failed(mut self, input: i32) -> Self {
        self.setup_failed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn set_setup_failed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.setup_failed = input;
        self
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn get_setup_failed(&self) -> &::std::option::Option<i32> {
        &self.setup_failed
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn shutting_down(mut self, input: i32) -> Self {
        self.shutting_down = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn set_shutting_down(mut self, input: ::std::option::Option<i32>) -> Self {
        self.shutting_down = input;
        self
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn get_shutting_down(&self) -> &::std::option::Option<i32> {
        &self.shutting_down
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn start_failed(mut self, input: i32) -> Self {
        self.start_failed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn set_start_failed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.start_failed = input;
        self
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn get_start_failed(&self) -> &::std::option::Option<i32> {
        &self.start_failed
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn stop_failed(mut self, input: i32) -> Self {
        self.stop_failed = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn set_stop_failed(mut self, input: ::std::option::Option<i32>) -> Self {
        self.stop_failed = input;
        self
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn get_stop_failed(&self) -> &::std::option::Option<i32> {
        &self.stop_failed
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn stopped(mut self, input: i32) -> Self {
        self.stopped = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn set_stopped(mut self, input: ::std::option::Option<i32>) -> Self {
        self.stopped = input;
        self
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn get_stopped(&self) -> &::std::option::Option<i32> {
        &self.stopped
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn stopping(mut self, input: i32) -> Self {
        self.stopping = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn set_stopping(mut self, input: ::std::option::Option<i32>) -> Self {
        self.stopping = input;
        self
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn get_stopping(&self) -> &::std::option::Option<i32> {
        &self.stopping
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn terminated(mut self, input: i32) -> Self {
        self.terminated = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn set_terminated(mut self, input: ::std::option::Option<i32>) -> Self {
        self.terminated = input;
        self
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn get_terminated(&self) -> &::std::option::Option<i32> {
        &self.terminated
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn terminating(mut self, input: i32) -> Self {
        self.terminating = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn set_terminating(mut self, input: ::std::option::Option<i32>) -> Self {
        self.terminating = input;
        self
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn get_terminating(&self) -> &::std::option::Option<i32> {
        &self.terminating
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn unassigning(mut self, input: i32) -> Self {
        self.unassigning = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn set_unassigning(mut self, input: ::std::option::Option<i32>) -> Self {
        self.unassigning = input;
        self
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn get_unassigning(&self) -> &::std::option::Option<i32> {
        &self.unassigning
    }
    /// Consumes the builder and constructs a [`InstancesCount`](crate::types::InstancesCount).
    pub fn build(self) -> crate::types::InstancesCount {
        crate::types::InstancesCount {
            assigning: self.assigning,
            booting: self.booting,
            connection_lost: self.connection_lost,
            deregistering: self.deregistering,
            online: self.online,
            pending: self.pending,
            rebooting: self.rebooting,
            registered: self.registered,
            registering: self.registering,
            requested: self.requested,
            running_setup: self.running_setup,
            setup_failed: self.setup_failed,
            shutting_down: self.shutting_down,
            start_failed: self.start_failed,
            stop_failed: self.stop_failed,
            stopped: self.stopped,
            stopping: self.stopping,
            terminated: self.terminated,
            terminating: self.terminating,
            unassigning: self.unassigning,
        }
    }
}
